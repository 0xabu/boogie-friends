<div class="conM "><p>This page illustrates many of the most common language features in Dafny.</p>
<h2>Programs</h2>
<p>At the top level, a Dafny program (stored as a file with extension .dfy) is a set of declarations. The declarations introduce fields, methods, and functions, as well as classes and inductive datatypes, where the order of introduction is irrelevant. A class also contains a set of declarations, introducing fields, methods, and functions. Fields, methods, and functions declared outside a class go into an implicit class called _default, giving the appearance of the program having global variables, procedures, and functions. If the program contains a unique parameter-less method called Main, then program execution starts there, but it is not necessary to have a main method to do verification.</p>
<p>Comments start with <span style="COLOR: #007f00">//</span> and go to the end of the line, or start with <span style="COLOR: #007f00">/*</span> and end with <span style="COLOR: #007f00">*/</span> and can be nested.</p>
<h2>Fields</h2>
<p>A field x of some type T is declared as:</p>
<pre><code>var</code> x: T;</pre>
<p>Unlike for local variables and bound variables, the type is required and will not be inferred. The field can be declared to be a ghost field by preceding the declaration with the keyword <code>ghost</code>. Dafny’s types include <code>bool</code> for booleans, <code>int</code> for mathematical (that is, unbounded) integers, user-defined classes and inductive datatypes, <code>set&lt;T&gt;</code> for a finite mathematical (immutable) set of T values (where T is any type), and <code>seq&lt;T&gt;</code> for a mathematical (immutable) sequence of T values. In addition, there are array types (which are like predefined “class” types) of one and more dimensions, written <code>array&lt;T&gt;</code>, <code>array2&lt;T&gt;</code>, <code>array3&lt;T&gt;</code>, …. The type <code>object</code> is a supertype of all class types, that is, an object denotes any reference, including <code>null</code>. Finally, the type <code>nat</code> denotes a subrange of <code>int</code>, namely the non-negative integers.</p>
<h2>Methods</h2>
<p>A method declaration has the form:</p>
<pre><code>method</code> M(a: A, b: B, c: C) <code>returns</code> (x: X, y: Y, z: Y)<br/>  <code>requires</code> Pre;<br/>  <code>modifies</code> Frame;<br/>  <code>ensures</code> Post;<br/>  <code>decreases</code> Rank;<br/>{<br/>  Body<br/>}</pre>
<p>where a, b, c are the method’s in-parameters, x, y, z are the method’s out-parameters, Pre is a boolean expression denoting the method’s precondition, Frame denotes a set of objects whose fields may be updated by the method, Post is a boolean expression denoting the method’s postcondition, Rank is the method’s variant function, and Body is a statement that implements the method. Frame can be a list of expressions, each of which is a set of objects or a single object, the latter standing for the singleton set consisting of that one object. The method’s frame is the union of these sets, plus the set of objects allocated by the method body.  For example, if c and d are parameters of a class type C, then</p>
<pre><code>modifies</code> {c, d};</pre>
<pre><code>modifies</code> {c} + {d};</pre>
<pre><code>modifies</code> c, {d};</pre>
<pre><code>modifies</code> c, d;</pre>
<p>all mean the same thing.</p>
<p>If omitted, the pre- and postconditions default to true and the frame defaults to the empty set. The variant function is a list of expressions, denoting the unending lexicographic tuple consisting of the given expressions followed implicitly by “top” elements. If omitted, Dafny will guess a variant function for the method, namely the lexicographic tuple that starts with the list of the method’s in-parameters.</p>
<p>A method can be declared as ghost by preceding the declaration with the keyword <code>ghost</code>. By default, a method has an implicit receiver parameter, <code>this</code>. This parameter can be removed by preceding the method declaration with the keyword <code>static</code>. A static method M in a class C can be invoked by C.M(…).</p>
<p>In a class, a method can be declared to be a constructor method by replacing the keyword <code>method </code>with the keyword <code>constructor</code>. A constructor can only be called at the time an object is allocated (see object-creation examples below), and for a class that contains one or more constructors, object creation must be done in conjunction with a call to a constructor.</p>
<h2>Functions</h2>
<p>A function declaration has the form:</p>
<pre><code>function</code> F(a: A, b: B, c: C): T<br/>  <code>requires</code> Pre;<br/>  <code>reads</code> Frame;<br/>  <code>ensures</code> Post;<br/>  <code>decreases</code> Rank;<br/>{<br/>  Body<br/>}</pre>
<p>where a, b, c are the method’s parameters, T is the type of the function’s result, Pre is a boolean expression denoting the function’s precondition, Frame denotes a set of objects whose fields the function body may depend on, Post is a boolean expression denoting the function’s postcondition, Rank is the function’s variant function, and Body is an expression that defines the function. The precondition allows a function to be partial, that is, the precondition says when the function is defined (and Dafny will verify that every use of the function meets the precondition). The postcondition is usually not needed, since the body of the function gives the full definition. However, the postcondition can be a convenient place to declare properties of the function that may require an inductive proof to establish. For example:</p>
<pre><code>function</code> Factorial(n: <code>int</code>): <code>int</code><br/>  <code>requires</code> 0 &lt;= n;<br/>  <code>ensures</code> 1 &lt;= Factorial(n);<br/>{<br/>  <code>if</code> n == 0 <code>then</code> 1 <code>else</code> Factorial(n-1) * n<br/>}</pre>
<p>says that the result of Factorial is always positive, which Dafny verifies inductively from the function body. To refer to the function’s result in the postcondition, use the function itself, as shown in the example.</p>
<p>By default, a function is ghost, and cannot be called from non-ghost code. To make it non-ghost, replace the keyword <code>function </code>with the two keywords <code>function method</code>.</p>
<p>By default, a function has an implicit receiver parameter, <code>this</code>. This parameter can be removed by preceding the function declaration with the keyword <code>static</code>. A static function F in a class C can be invoked by F.M(…). This can give a convenient way to declare a number of helper functions in a separate class.</p>
<h2>Classes</h2>
<p>A class is defined as follows:</p>
<pre><code>class</code> C {<br/>  // member declarations go here<br/>}</pre>
<p>where the members of the class (fields, methods, and functions) are defined (as described above) inside the curly braces.</p>
<h2>Datatypes</h2>
<p>An inductive datatype is a type whose values are created using a fixed set of constructors. A datatype Tree with constructors Empty and Node is declared as follows:</p>
<pre><code>datatype </code>Tree = Empty | Node(Tree, <code>int</code>, Tree)</pre>
<p>The constructors are separated by vertical bars. Parameter-less constructors need not use parentheses, as is shown here for Empty.</p>
<p>For each constructor Ct, the datatype implicitly declares a boolean member Ct?, which returns <code>true</code> for those values that have been constructed using Ct. For example, after the code snippet:</p>
<pre><code>var</code> t0 := Empty;<br/><code>var</code> t1 := Node(t0, 5, t0);</pre>
<p>the expression t1.Node? evaluates to <code>true</code> and t0.Node? evaluates to <code>false</code>. Two datatype values are equal if they have been created using the same constructor and the same parameters to that constructor. Therefore, for parameter-less constructors like Empty, t.Empty? gives the same result as t == Empty.</p>
<p>A constructor can optionally declare a destructor for any of its parameters, which is done by introducing a name for the parameter. For example, if Tree were declared as:</p>
<pre><code>datatype</code> Tree = Empty | Node(left: Tree, data: <code>int</code>, right: Tree)</pre>
<p>then t1.data == 5 and t1.left == t0 hold after the code snippet above.</p>
<h2>Generics</h2>
<p>Dafny supports generic types. That is, any class, inductive datatype, method, and function can have type parameters. These are declared in angle brackets after the name of what is being declared. For example:</p>
<pre><code>class</code> Multiset&lt;T&gt; { /*…*/ }<br/><code>datatype</code> Tree&lt;T&gt; = Empty | Node(Tree&lt;T&gt;, T, Tree&lt;T&gt;)<br/><code>method</code> Find&lt;T&gt;(key: T, collection: Tree&lt;T&gt;) { /*…*/ }<br/><code>function</code> IfThenElse&lt;T&gt;(b: <code>bool</code>, x: T, y: T): T { /*…*/ }</pre>
<h2>Statements</h2>
<p>Here are examples of the most common statements in Dafny.</p>
<pre><code>var </code>LocalVariables := ExprList;<br/>Lvalues := ExprList;<br/><code>assert</code> BoolExpr;<br/><code>print</code> PrintList;</pre>
<pre><code>if</code> BoolExpr0 {<br/>  Stmts0<br/>} <code>else if</code> BoolExpr1 {<br/>  Stmts1<br/>} <code>else</code> {<br/>  Stmts2<br/>}</pre>
<pre><code>while</code> BoolExpr<br/>  <code>invariant</code> Inv;<br/>  <code>modifies</code> Frame;<br/>  <code>decreases</code> Rank;<br/>{<br/>  Stmts<br/>}</pre>
<pre><code>match</code> Expr {<br/>  <code>case</code> Empty =&gt; Stmts0<br/>  <code>case</code> Node(l, d, r) =&gt; Stmts1<br/>}</pre>
<pre><code>break</code>;<br/><code>return</code>;</pre>
<p>The <code>var</code> statement introduces local variables (which are not allowed to shadow other variables declared inside the same set of most tightly enclosing curly braces). Each variable can optionally be followed by :T for any type T, which explicitly gives the preceding variable the type T (rather than being inferred). The ExprList with initial values is optional. To declare the variables as ghost variables, precede the declaration with the keyword <code>ghost</code>.</p>
<p>The assignment statement assigns each right-hand side in ExprList to the corresponding left-hand side in Lvalues. These assignments are performed in parallel, so the left-hand sides must denote distinct L-values. Each right-hand side can be an expression or an object creation of one of the following forms:</p>
<pre><code>new</code> T<br/><code>new</code> T.Init(ExprList)<br/><code>new</code> T[SizeExpr]<br/><code>new</code> T[SizeExpr0, SizeExpr1]</pre>
<p>The first form allocates an object of type T. The second form additionally invokes an initialization method or constructor on the newly allocated object. The other forms show examples of array allocations, in particular a one- and a two-dimensional array of T values, respectively.</p>
<p>The entire right-hand side of an assignment can also be a method call, in which case the left-hand sides are the actual out-parameters (omitting the := if there are no out-parameters).</p>
<p>The <code>assert</code> statement claims that the given expression evaluates to <code>true</code> (which is checked by the verifier).</p>
<p>The <code>print </code>statement outputs to standard output the values of the given print expressions. A print expression is either an expression or a string literal (where \n is used to denote a newline character).</p>
<p>The <code>if</code> statement is the usual one. The example shows stringing together alternatives using <code>else if</code>. The <code>else</code> branch is optional, as usual.</p>
<p>The <code>while</code> statement is the usual loop, where the <code>invariant</code> declaration gives a loop invariant, the <code>modifies</code> clause restricts the modification frame of the loop, and the <code>decreases</code> clause introduces a variant function for the loop. By default, the loop invariant is <code>true</code>, the modification frame is the same as in the enclosing context (usually the <code>modifies</code> clause of the enclosing method), and the variant function is guessed from the loop guard.</p>
<p>The <code>match</code> statement evaluates the source Expr, an expression whose type is an inductive datatype, and then executes the <code>case</code> corresponding to which constructor was used to create the source datatype value, binding the constructor parameters to the given names.</p>
<p>The <code>break</code> statement can be used to exit loops, and the <code>return</code> statement can be used to exit a method.</p>
<h2>Expressions</h2>
<p>The expressions in Dafny are quite similar to those in Java-like languages. Here are some noteworthy differences.</p>
<p>In addition to the short-circuiting boolean operators &amp;&amp; (and) and || (or), Dafny has a short-circuiting implication operator ==&gt; and an if-and-only-if operator &lt;==&gt;. As suggested by their widths, &lt;==&gt; has lower binding power than ==&gt;, which in turn has lower binding power than &amp;&amp; and ||.</p>
<p>Dafny comparison expressions can be chaining, which means that comparisons “in the same direction” can be strung together. For example,</p>
<p>0 &lt;= i &lt; j &lt;= a.Length == N</p>
<p>has the same meaning as:</p>
<p>0 &lt;= i &amp;&amp; i &lt; j &amp;&amp; j &lt;= a.Length &amp;&amp; a.Length == N</p>
<p>Note that boolean equality can be expressed using both == and &lt;==&gt;. There are two differences between these. First, == has a stronger binding power than &lt;==&gt;. Second, == is chaining while &lt;==&gt; is associative. That is, a == b == c is the same as a == b &amp;&amp; b == c, whereas a &lt;==&gt; b &lt;==&gt; c is the same as a &lt;==&gt; (b &lt;==&gt; c), which is also the same as (a &lt;==&gt; b) &lt;==&gt; c.</p>
<p>Operations on integers are the usual ones, except that / (integer division) and % (integer modulo) follow the Euclidean definition, which means that % always results in a non-negative number. (Hence, when the first argument to / or % is negative, the result is different than what you get in C, Java, or C#, see <a href="http://en.wikipedia.org/wiki/Modulo_operation" onclick="stc(this, 16)" target="_self">http://en.wikipedia.org/wiki/Modulo_operation</a>.)</p>
<p>Dafny expressions include universal and existential quantifiers, which have the form:</p>
<pre><code>forall</code> x :: Expr</pre>
<p>and likewise for <code>exists</code>, where x is a bound variable (which can be declared with an explicit type, as in x: T) and Expr is a boolean expression. </p>
<p>Operations on sets include + (union), * (intersection), and - (set difference), as well as the set comparison operators &lt; (proper subset), &lt;= (subset), their duals &gt; and &gt;=, and !! (disjointness). The expression x <code>in</code> S says that x is a member of set S, and x !<code>in</code> S is a convenient way of writing !(x <code>in</code> S). To make a set from some elements, enclose them in curly braces. For example, {x,y} is the set consisting of x and y (which is a singleton set if x == y), {x} is the singleton set containing x, and {} is the empty set.</p>
<p>Operations on sequences include + (concatenation) and the comparison operators &lt; (proper prefix) and &lt;= (prefix). Membership can be checked like for sets: x <code>in</code> S and x !<code>in</code> S. The length of a sequence S is denoted |S|, and the elements of such a sequence have indices from 0 to less than |S|. The expression S[j] denotes the element at index j of sequence S. The expression S[m..n], where 0 &lt;= m &lt;= n &lt;= |S|, returns a sequence whose elements are the n-m elements of S starting at index m (that is, from S[m], S[m+1], … up to but not including S[n]). The expression S[m..] (often called “drop m”) is the same as S[m..|S|], that is, it returns the sequence whose elements are all but the first m elements of S. The expression S[..n] (often called “take n”) is the same as S[0..n], that is, it returns the sequence that consists of the first n elements of S. If j is a valid index into sequence S, then the expression S[j := x] is the sequence that is like S except that it has x at index j. Finally, to make a sequence from some elements, enclose them in square brackets. For example, [x,y] is the sequence consisting of the two elements x and y such that [x,y][0] == x and [x,y][1] == y, [x] is the singleton sequence whose only element is x, and [] is the empty sequence.</p>
<p>The if-then-else expression has the form:</p>
<pre><code>if</code> BoolExpr <code>then</code> Expr0 <code>else</code> Else1</pre>
<p>where Expr0 and Expr1 are any expressions of the same type. Unlike the <code>if</code> statement, the if-then-else expression uses the <code>then</code> keyword, and must include an explicit else branch.</p>
<p>The <code>match</code> statement also has an analogous <code>match</code> expression, which has a form like:</p>
<pre><code>match</code> Expr<br/><code>case</code> Empty =&gt; Expr0<br/><code>case</code> Node(l, d, r) =&gt; Expr1</pre>
<p>Note that the <code>match</code> expression does not surround the cases with curly braces.</p></div>